# 鉴权方案对比：Middleware vs 客户端鉴权

## 📊 方案对比

| 特性             | 方案 A：Middleware 鉴权       | 方案 B：客户端鉴权（AuthGuard） |
| ---------------- | ----------------------------- | ------------------------------- |
| **保护页面路由** | ✅ 服务端拦截，无法绕过       | ⚠️ 客户端检查，可被绕过         |
| **安全性**       | ✅ 高（服务端验证）           | ⚠️ 中（客户端验证）             |
| **用户体验**     | ✅ 立即重定向，无闪烁         | ⚠️ 可能先显示页面再跳转         |
| **SEO**          | ✅ 未授权页面不会渲染         | ⚠️ 页面会先加载                 |
| **实现复杂度**   | ⚠️ 需要处理 Edge Runtime 限制 | ✅ 简单（使用 localStorage）    |
| **Token 存储**   | Cookie（httpOnly 更安全）     | localStorage（易受 XSS）        |

## 🎯 你的情况分析

### 当前架构：

- ✅ 前端直接调用后端 API `https://api.titlelab.ai`
- ✅ 使用 Next.js 代理 `/api/proxy/` 避免跨域
- ✅ Token 存储在 `localStorage`
- ✅ 后端 API 会验证 token

### 需要保护的内容：

1. **API 调用** ✅ 已保护（后端验证）
2. **页面路由** ❓ 需要决定

## 💡 推荐方案

### 方案一：简化 Middleware（推荐）

**适用场景**：只需要保护页面路由，不需要复杂的 token 验证

```typescript
// src/middleware.ts
export function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;

  // 公共路由
  const publicRoutes = ["/auth/login", "/auth/register", "/api", "/_next"];
  if (publicRoutes.some((path) => pathname.startsWith(path))) {
    return NextResponse.next();
  }

  // 只检查 token 是否存在（不验证签名）
  const token = request.cookies.get("accessToken")?.value;

  if (!token) {
    return NextResponse.redirect(new URL("/auth/login", request.url));
  }

  return NextResponse.next();
}
```

**优点**：

- ✅ 简单，不需要 JWT 验证库
- ✅ 保护页面路由
- ✅ 后端 API 会做完整验证

### 方案二：客户端 AuthGuard（如果不需要 SSR）

**适用场景**：所有页面都是客户端组件，不需要服务端保护

```typescript
// src/components/guards/AuthGuard.tsx
"use client";
import { useEffect } from "react";
import { useRouter } from "next/navigation";

export default function AuthGuard({ children }: { children: React.ReactNode }) {
  const router = useRouter();

  useEffect(() => {
    const token = localStorage.getItem("token");
    if (!token) {
      router.push("/auth/login");
    }
  }, [router]);

  return <>{children}</>;
}
```

**优点**：

- ✅ 实现简单
- ✅ 可以使用 localStorage
- ⚠️ 但安全性较低（可被绕过）

### 方案三：不需要 Middleware（如果页面都是公开的）

**适用场景**：所有页面都可以访问，只在 API 调用时验证

- 移除 middleware 鉴权
- 只在 API 调用时验证 token
- 页面路由不保护

## 🎯 我的建议

### 推荐：**方案一（简化 Middleware）**

**理由**：

1. ✅ **保护页面路由**：防止未授权用户直接访问 `/dashboard`、`/user-profile` 等
2. ✅ **简单实现**：只需要检查 token 是否存在，不需要验证签名
3. ✅ **后端验证**：完整的 token 验证由后端 API 完成
4. ✅ **更好的用户体验**：服务端重定向，无闪烁

### 实现步骤：

1. **登录时设置 Cookie**（如果后端返回 token）：

```typescript
// 登录成功后
document.cookie = `accessToken=${token}; path=/; max-age=86400; SameSite=Strict`;
```

2. **简化 Middleware**（只检查存在性）：

```typescript
// 不需要验证签名，后端会验证
const token = request.cookies.get("accessToken")?.value;
if (!token) {
  return NextResponse.redirect(new URL("/auth/login", request.url));
}
```

3. **API 调用时使用 localStorage 的 token**：

```typescript
// apiAxios 拦截器已经处理了
const token = localStorage.getItem("token");
config.headers.Authorization = `Bearer ${token}`;
```

## ❌ 不推荐：完全移除 Middleware

**原因**：

- 未授权用户可以直接访问 `/dashboard`、`/user-profile` 等页面
- 虽然 API 会返回 401，但页面已经加载了
- 用户体验差（先看到页面，然后才跳转）

## 🔧 最佳实践

**混合方案**：

1. **Middleware**：保护页面路由（检查 token 存在性）
2. **后端 API**：完整验证 token（签名、过期等）
3. **客户端**：使用 localStorage 存储 token，用于 API 调用

这样既保护了页面路由，又保持了实现的简单性。
